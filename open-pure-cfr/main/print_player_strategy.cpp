/* print_player_strategy.cpp
 * Richard Gibson, Jul 29, 2013
 * Email: richard.g.gibson@gmail.com
 *
 * Simple tool to print a player generated by Pure CFR in human-readable format.
 *
 * Copyright (C) 2013 by Richard Gibson
 */

/* C / C++ includes */
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* C project-acpc-server includes */
extern "C" {
}

/* Pure CFR includes */
#include "constants.hpp"
#include "player_module.hpp"

static void print_strategy_r( PlayerModule &player_module,
			      State &state,
			      const AbstractGame *ag,
			      const int p,
			      const int max_round )
{
  if( state.finished || ( state.round >= max_round ) ) {
    /* End of game or we've gone past the rounds we care to print */
    return;
  }

  /* Get the possible actions */
  Action actions[ MAX_ABSTRACT_ACTIONS ];
  const int num_choices = ag->action_abs->get_actions( ag->game, state, actions );
    
  if( p == currentPlayer( ag->game, &state ) ) {
    /* Get the state info in a string */
    char state_str[ PATH_LENGTH ];
    printState( ag->game, &state, PATH_LENGTH, state_str );
    /* Remove the card information from the state string by finding the last colon
     * and ending the string there, then print the state.
     */
    for( int i = strlen( state_str) - 1; i >= 0 && i < PATH_LENGTH; --i ) {
      if( state_str[ i ] == ':' ) {
	state_str[ i ] = '\0';
	break;
      }
    }
    printf( "%s\n", state_str );
  
    /* Print the player's action probabilities for every possible bucket */
    const int num_buckets = ag->card_abs->num_buckets( ag->game, state );
    for( int bucket = 0; bucket < num_buckets; ++bucket ) {

      /* Get the action probabilities */
      double action_probs[ MAX_ABSTRACT_ACTIONS ];
      player_module.get_action_probs( state, action_probs, bucket );

      /* Print 'em out */
      printf( "  Bucket %d:", bucket );
      for( int a = 0; a < num_choices; ++a ) {
	if( ( num_choices < 5 ) || ( action_probs[ a ] > 0.001 ) ) {
	  char action_str[ PATH_LENGTH ];
	  printAction( ag->game, &actions[ a ], PATH_LENGTH, action_str );
	  printf( " %lg%%%s", action_probs[ a ] * 100, action_str );
	}
      }
      printf( "\n" );
    }
  }

  /* Recurse */
  for( int a = 0; a < num_choices; ++a ) {

    State new_state( state );
    doAction( ag->game, &actions[ a ], &new_state );
    print_strategy_r( player_module, new_state, ag, p, max_round );
  }
}

int main( const int argc, const char *argv[] )
{
  /* Print usage */
  if( argc < 2 ) {
    fprintf( stderr, "Usage: %s <player_file> [options]\n", argv[ 0 ] );
    fprintf( stderr, "Options:\n" );
    fprintf( stderr, "  --max-round=<round>\n" );
    return 1;
  }

  /* Create the player, get the abstract game */
  int index = 1;
  fprintf( stderr, "Loading player module... " );
  PlayerModule player_module( argv[ index ] );
  fprintf( stderr, "done!\n" );
  ++index;
  const AbstractGame *ag = player_module.get_abstract_game( );

  /* Check for options */
  int max_round = MAX_ROUNDS;
  for( ; index < argc; ++index ) {
    if( !strncmp( argv[ index ], "--max-round=", strlen( "--max-round=" ) ) ) {
      if( sscanf( &argv[ index ][ strlen( "--max-round=" ) ], "%d",
		  &max_round ) < 1 ) {
	fprintf( stderr, "Could not read max-round from argument [%s]\n",
		 argv[ index ] );
	return 1;
      }
      if( ( max_round <= 0 ) || ( max_round > MAX_ROUNDS ) ) {
	fprintf( stderr, "max-round must be between 1 and %d\n", MAX_ROUNDS );
	return 1;
      }
    } else {
      fprintf( stderr, "Unrecognized argument [%s]\n", argv[ index ] );
      return 1;
    }
  }

  /* Print the strategy */
  fprintf( stderr, "Starting walk of abstract game tree...\n" );
  State state;
  for( int p = 0; p < ag->game->numPlayers; ++p ) {
    initState( ag->game, 0, &state );
    printf( "=== PLAYER %d ===\n", p + 1 );
    print_strategy_r( player_module, state, ag, p, max_round );
  }

  return 0;
}
